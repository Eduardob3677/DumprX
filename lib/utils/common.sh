#!/bin/bash
# DumprX Utility Functions Module
# Common utility functions used across the project

# Source messaging module
source "$(dirname "${BASH_SOURCE[0]}")/../messaging/ui.sh"

# File processing utilities
detox_files() {
    local directory="$1"
    
    if command -v detox >/dev/null 2>&1; then
        msg_tool "Sanitizing filenames..."
        find "$directory" -depth -exec detox -r {} \; 2>/dev/null
    fi
}

# SHA1 sum generation
write_sha1sum() {
    local input_file="$1"
    local output_file="$2"
    
    if [[ -f "$input_file" ]]; then
        msg_progress "Generating SHA1 checksums..."
        
        {
            echo "# SHA1 checksums generated by DumprX v2.0"
            echo "# $(date)"
            echo ""
            
            while IFS= read -r file_path; do
                if [[ -f "$file_path" ]]; then
                    local sha1sum_result
                    sha1sum_result=$(sha1sum "$file_path" 2>/dev/null)
                    if [[ -n "$sha1sum_result" ]]; then
                        echo "$sha1sum_result"
                    fi
                fi
            done < "$input_file"
        } > "$output_file"
        
        msg_success "SHA1 checksums generated: $(basename "$output_file")"
    fi
}

# File size checking
check_file_size() {
    local file_path="$1"
    local min_size_mb="${2:-1}"
    
    if [[ ! -f "$file_path" ]]; then
        return 1
    fi
    
    local file_size
    file_size=$(stat -c%s "$file_path" 2>/dev/null)
    local min_size_bytes=$((min_size_mb * 1024 * 1024))
    
    if [[ "$file_size" -ge "$min_size_bytes" ]]; then
        return 0
    else
        return 1
    fi
}

# Create directory with permissions
safe_mkdir() {
    local dir_path="$1"
    local permissions="${2:-755}"
    
    if ! mkdir -p "$dir_path" 2>/dev/null; then
        msg_error "Failed to create directory: $dir_path"
        return 1
    fi
    
    chmod "$permissions" "$dir_path" 2>/dev/null || true
}

# Copy files with progress
copy_with_progress() {
    local source="$1"
    local destination="$2"
    local description="${3:-Copying files}"
    
    if [[ -d "$source" ]]; then
        local total_files
        total_files=$(find "$source" -type f | wc -l)
        local current_file=0
        
        find "$source" -type f | while read -r file; do
            local relative_path="${file#$source/}"
            local dest_file="$destination/$relative_path"
            
            # Create destination directory
            mkdir -p "$(dirname "$dest_file")"
            
            # Copy file
            if cp "$file" "$dest_file" 2>/dev/null; then
                ((current_file++))
                show_progress "$current_file" "$total_files" "$description"
            fi
        done
    elif [[ -f "$source" ]]; then
        cp "$source" "$destination" 2>/dev/null
    fi
}

# Extract file information
get_file_info() {
    local file_path="$1"
    local info_type="${2:-all}"
    
    if [[ ! -f "$file_path" ]]; then
        return 1
    fi
    
    case "$info_type" in
        "size")
            stat -c%s "$file_path" 2>/dev/null
            ;;
        "type")
            file -b "$file_path" 2>/dev/null
            ;;
        "mime")
            file -b --mime-type "$file_path" 2>/dev/null
            ;;
        "all")
            {
                echo "File: $(basename "$file_path")"
                echo "Size: $(stat -c%s "$file_path" 2>/dev/null || echo "unknown") bytes"
                echo "Type: $(file -b "$file_path" 2>/dev/null || echo "unknown")"
                echo "MIME: $(file -b --mime-type "$file_path" 2>/dev/null || echo "unknown")"
                echo "Modified: $(stat -c%y "$file_path" 2>/dev/null | cut -d'.' -f1 || echo "unknown")"
            }
            ;;
    esac
}

# Check tool availability
check_tool() {
    local tool_name="$1"
    local required="${2:-false}"
    
    if command -v "$tool_name" >/dev/null 2>&1; then
        msg_success "Tool available: $tool_name"
        return 0
    else
        if [[ "$required" == "true" ]]; then
            msg_error "Required tool not found: $tool_name"
            return 1
        else
            msg_warning "Optional tool not found: $tool_name"
            return 1
        fi
    fi
}

# System resource monitoring
check_disk_space() {
    local directory="$1"
    local required_gb="${2:-5}"
    
    local available_gb
    available_gb=$(df -BG "$directory" 2>/dev/null | awk 'NR==2 {print $4}' | sed 's/G//')
    
    if [[ "$available_gb" -ge "$required_gb" ]]; then
        msg_success "Sufficient disk space: ${available_gb}GB available"
        return 0
    else
        msg_warning "Low disk space: only ${available_gb}GB available (${required_gb}GB required)"
        return 1
    fi
}

# Memory usage check
check_memory() {
    local required_mb="${1:-2048}"
    
    local available_mb
    available_mb=$(free -m | awk 'NR==2{print $7}')
    
    if [[ "$available_mb" -ge "$required_mb" ]]; then
        msg_success "Sufficient memory: ${available_mb}MB available"
        return 0
    else
        msg_warning "Low memory: only ${available_mb}MB available (${required_mb}MB required)"
        return 1
    fi
}

# Cleanup functions
cleanup_temp_files() {
    local base_dir="${1:-$TMPDIR}"
    
    if [[ -d "$base_dir" ]]; then
        msg_progress "Cleaning up temporary files..."
        
        # Remove common temporary files
        find "$base_dir" -name "*.tmp" -delete 2>/dev/null || true
        find "$base_dir" -name "*.temp" -delete 2>/dev/null || true
        find "$base_dir" -name "*.log" -delete 2>/dev/null || true
        find "$base_dir" -name "core.*" -delete 2>/dev/null || true
        
        msg_success "Temporary files cleaned"
    fi
}

# Archive file validation
validate_archive() {
    local archive_path="$1"
    local archive_type="${2:-auto}"
    
    if [[ ! -f "$archive_path" ]]; then
        return 1
    fi
    
    # Auto-detect archive type if not specified
    if [[ "$archive_type" == "auto" ]]; then
        case "$(file -b "$archive_path")" in
            *"Zip archive"*) archive_type="zip" ;;
            *"RAR archive"*) archive_type="rar" ;;
            *"7-zip archive"*) archive_type="7z" ;;
            *"tar archive"*) archive_type="tar" ;;
            *) return 1 ;;
        esac
    fi
    
    # Validate based on type
    case "$archive_type" in
        "zip")
            unzip -t "$archive_path" >/dev/null 2>&1
            ;;
        "rar")
            unrar t "$archive_path" >/dev/null 2>&1
            ;;
        "7z")
            7zz t "$archive_path" >/dev/null 2>&1
            ;;
        "tar")
            tar -tf "$archive_path" >/dev/null 2>&1
            ;;
        *)
            return 1
            ;;
    esac
}

# Network connectivity check
check_network() {
    local test_url="${1:-https://www.google.com}"
    
    if curl -s --max-time 10 --head "$test_url" >/dev/null 2>&1; then
        msg_success "Network connectivity confirmed"
        return 0
    else
        msg_warning "Network connectivity issues detected"
        return 1
    fi
}

# Git repository utilities
setup_git_repo() {
    local repo_dir="$1"
    local repo_name="$2"
    local description="$3"
    
    cd "$repo_dir" || return 1
    
    # Initialize git if not already done
    if [[ ! -d ".git" ]]; then
        git init -q
        msg_success "Git repository initialized"
    fi
    
    # Configure git
    git config user.name "DumprX" 2>/dev/null || true
    git config user.email "dumprx@noreply.com" 2>/dev/null || true
    
    # Create README if it doesn't exist
    if [[ ! -f "README.md" ]]; then
        {
            echo "# $repo_name"
            echo ""
            echo "$description"
            echo ""
            echo "Extracted with DumprX v2.0 - Advanced Firmware Extraction Toolkit"
            echo ""
            echo "## Contents"
            echo ""
            find . -name "*.img" -exec basename {} \; | sort | sed 's/^/- /'
        } > README.md
        
        msg_success "README.md generated"
    fi
}

# File deduplication
deduplicate_files() {
    local directory="$1"
    
    msg_progress "Checking for duplicate files..."
    
    # Find files with same size and then check SHA1
    find "$directory" -type f -exec stat -c '%s %n' {} \; | \
    sort -nr | \
    uniq -D -w 10 | \
    while read -r size filename; do
        if [[ -f "$filename" ]]; then
            local sha1
            sha1=$(sha1sum "$filename" | cut -d' ' -f1)
            echo "$sha1 $filename"
        fi
    done | \
    sort | \
    uniq -D -w 40 | \
    while read -r sha1 filename; do
        # Keep the first occurrence, mark others for removal
        if [[ ! -f "${filename}.keep" ]]; then
            touch "${filename}.keep"
            msg_info "Keeping: $(basename "$filename")"
        else
            msg_warning "Duplicate found: $(basename "$filename")"
            rm -f "$filename"
        fi
    done
    
    # Clean up marker files
    find "$directory" -name "*.keep" -delete 2>/dev/null || true
    
    msg_success "File deduplication completed"
}

# Performance monitoring
monitor_extraction() {
    local pid="$1"
    local description="$2"
    
    if [[ ! -d "/proc/$pid" ]]; then
        return 1
    fi
    
    msg_progress "Monitoring: $description (PID: $pid)"
    
    while [[ -d "/proc/$pid" ]]; do
        local cpu_usage
        local mem_usage
        
        # Get CPU and memory usage
        if [[ -f "/proc/$pid/stat" ]]; then
            cpu_usage=$(ps -p "$pid" -o %cpu --no-headers 2>/dev/null | tr -d ' ')
            mem_usage=$(ps -p "$pid" -o %mem --no-headers 2>/dev/null | tr -d ' ')
            
            if [[ -n "$cpu_usage" && -n "$mem_usage" ]]; then
                printf "\r${C_CYAN}${ICON_PROGRESS} %s - CPU: %s%% MEM: %s%%${C_CLEAR}" \
                    "$description" "$cpu_usage" "$mem_usage"
            fi
        fi
        
        sleep 2
    done
    
    echo
    msg_success "Process completed: $description"
}

# Export functions
export -f detox_files write_sha1sum check_file_size safe_mkdir copy_with_progress
export -f get_file_info check_tool check_disk_space check_memory cleanup_temp_files
export -f validate_archive check_network setup_git_repo deduplicate_files monitor_extraction